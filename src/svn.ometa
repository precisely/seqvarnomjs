var elements = require('./elements');
var constants = require('./constants');

var NARefAlt = elements.NARefAlt;
var Interval = elements.Interval;
var BaseOffsetInterval = elements.NARefAlt;
var SequenceVariant = elements.SequenceVariant;
var SimpleVariant = elements.SimpleVariant;
var TransVariant = elements.TransVariant;
var CisVariant = elements.CisVariant;
var UnphasedVariant = elements.UnphasedVariant;
var Inv = elements.Inv;

var binaryOperator = elements.binaryOperator;
var AndExpr = elements.AndExpr;
var OrExpr = elements.OrExpr;
var NotExpr = elements.NotExpr;
var LogicExpr = elements.LogicExpr;
ometa Logic {
  ////////////////////////////////////////////////////////////////////////////
  // Logic
  logic =
      logic:lhs binaryOperator:op logicTerm:rhs -> binaryOperator(op, lhs, rhs)
    | logicTerm,
  logicTerm = notExpr | groupedExpr | logic | baseExpr | anything:x ?(x instanceof LogicExpr),
  notExpr =
      '!' baseExpr:expr -> new NotExpr(expr)
    | '!' logic:expr -> new NotExpr(expr),
  groupedExpr = '{' logic:expr '}' -> expr,
  binaryOperator = '&' | '^',
  // Logic is
  // baseExpr - should be defined in subclasses

  ////////////////////////////////////////////////////////////////////////////
  // position primitives
  base = snum,
  num = <digit+>:x -> parseInt(x),
  nnum = <'-' num>:x -> parseInt(x),

  offset = snum | (-> 0),
  pm = ('-'|'+'):x -> x,
  snum = <pm? num>:x -> parseInt(x),

  letterOrDigit = <letter> | <digit>,

  ////////////////////////////////////////////////////////////////////////////
  // core patterns
  maybeIndefinite :pattern = apply(pattern) | '(' apply(pattern):obj ')' -> obj.setUncertain()
}

ometa GenomicSimple <: Logic {
  simpleVariantPattern :pos :edit = intervalPattern(pos):pos maybeIndefinite(edit):edit -> new SimpleVariant({pos:pos,edit:edit}),

  baseExpr  = variant,
  variant   = simpleVariantPattern(#pos, #dnaEdit),
  pos       = (num|'?'->null):pos -> pos,
  dnaEdit   = dnaIdent | dnaSubst | dnaDelins | dnaIns | dnaDel | dnaDup | dnaInv | dnaCopy, // dnaCon
  dnaIdent  = <dna*>:ref '='           -> null,
  dnaSubst  = dna:ref '>' dna:alt      -> new NARefAlt({ref:ref,alt:alt}),
  dnaDelins = 'del' (<num>|<dna*>):ref 'ins' <dna+>:alt  -> null,
  dnaDel    = 'del' (<num>|<dna*>):ref -> new NARefAlt({ref:ref,alt:null}),
  dnaIns    = 'ins' <dna+>:alt         -> new NARefAlt({ref:null,alt:ref}),
  dnaDup    = 'dup' <dna*>:ref         -> new Dup({ref:ref}),
  dnaInv    = 'inv' (<num>|<dna*>):ref -> new Inv({ref:null}),
  //dnaCon    = 'con' hgvsPosition:pos  -> new Conv({fromAc:pos.ac, fromType:pos.type, fromPos:pos.pos}),

  dnaCopy   = 'copy' num:n -> new NACopy({copy:n}),
  dna = dnaIupac,
  dnaIupac = ('A'|'C'|'G'|'T'|'R'|'Y'|'M'|'K'|'W'|'S'|'B'|'D'|'H'|'V'|'N'|'a'|'c'|'g'|'t'|'r'|'y'|'m'|'k'|'w'|'s'|'b'|'d'|'h'|'v'|'n'):x -> x,

  intervalPattern :pos =
    (apply(pos):start '_' apply(pos):end -> new Interval({start:start, end:end}))
    | '(' intervalPattern(pos):ip ')' -> ip.setUncertain()
    | apply(pos),

  baseOffsetIntervalPattern :pos =
      (apply(pos):start '_' apply(pos):end -> new BaseOffsetInterval({start:start, end:end}))
    | '(' intervalPattern(pos):ip ')' -> ip.setUncertain()
    | apply(pos)
}

ometa GenomicCis <: Logic {
  cisBracketPattern :elt =
      ('[' listOf(elt,';'):edits ?(edits.length===1) ']' -> edits[0])
    | ('[' listOf(elt,';'):edits ?(edits.length>1) ']' -> new CisVariant({variants:edits})),

  simpleLogic            = GenomicSimple.logic,
  simpleVariant          = GenomicSimple.variant,
  baseExpr               = cisBracketPattern(#simpleLogic),
  variant                = cisBracketPattern(#simpleVariant)
}

ometa GenomicTrans <: Logic {
  transPattern :elt = listOf(elt, ';'):variants ?(variants.length>1) -> new TransVariant({variants:variants}),
  cisLogic          = GenomicCis.logic,
  cisVariant        = GenomicCis.variant,
  baseExpr          = transPattern(#cisLogic),
  variant           = transPattern(#cisVariant)
}

ometa GenomicUnphased <: Logic {
  unphasedPattern :elt = listOf(elt, '(;)'):variants ?(variants.length>1) -> new UnphasedVariant({variants:variants}),
  baseExpr = unphasedPattern(), //phasedLogic
  phasedLogic = GenomicTrans.logic | GenomicCis.logic | GenomicSimple.logic,
  phasedVariants = GenomicTrans.variant | GenomicCis.variant,
  variant = unphasedPattern(#phasedVariants)
}

ometa SVN <: Logic {
  gVariant = GenomicUnphased.variant | GenomicTrans.variant | GenomicCis.variant | GenomicSimple.variant,
  gSeqVariant = seqVariantPattern('g', #gVariant),
  variant = gSeqVariant,
  gLogic = GenomicUnphased.logic | GenomicTrans.logic | GenomicCis.logic | GenomicSimple.logic,
  baseExpr = seqVariantPattern('g', #gLogic),

  // Accessions, possibly versioned. Should accept, e.g., NM_01234.5, LRG_01234_1p1
  accn = <letter letterOrDigit+ ('_' letterOrDigit+)? ('.' digit+)?>,

  variantType = 'g'|'c'|'p'|'r'|'n'|'m',

  seqVariantShorthandPattern :variantPattern = variantType:type '.' apply(variantPattern):variant -> new SequenceVariant({type:type, variant:variant}),

  seqVariantPattern :type :variantPattern =
      accn:accn ':' variantType:c ?(c===type) '.' apply(variantPattern):variant
        -> new SequenceVariant({ac:accn, type:c, variant:variant})
}

module.exports = {
  SVN:SVN,
  Logic:Logic,
  GenomicSimple:GenomicSimple,
  GenomicCis:GenomicCis,
  GenomicTrans:GenomicTrans,
  GenomicUnphased:GenomicUnphased
};